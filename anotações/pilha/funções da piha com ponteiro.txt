-----------------------------------------------------------------------------------------------------------
CODIGOS EM C++
-----------------------------------------------------------------------------------------------------------
Impelementação de Pilhas por
meio de Apontadores ou lista encadeada

#include <stdio.h>
#include <stdlib.h>

typedef int TipoChave;  // Define 'TipoChave' como um inteiro.

typedef struct {
    TipoChave chave;    // Campo 'chave' do tipo 'TipoChave'.
} TipoItem;             // Estrutura que representa o item armazenado na pilha.

typedef struct Celula *Apontador;  // Define 'Apontador' como um ponteiro para 'Celula'.

typedef struct Celula {
    TipoItem item;      // Item armazenado na célula.
    Apontador prox;     // Ponteiro para a próxima célula (nó) da pilha.
} Celula;               // Estrutura da célula que compõe a pilha.

typedef struct {
    Apontador topo;     // Ponteiro para o topo da pilha.
    Apontador fundo;    // Ponteiro para o fundo da pilha (célula base).
    int tamanho;        // Tamanho atual da pilha.
} TipoPilha;            // Estrutura que representa a pilha.




// Função que inicializa a pilha vazia.
void FPVazia(TipoPilha *pilha) {
    // Aloca memória para a célula cabeça.
    pilha->topo = (Apontador) malloc(sizeof(Celula));
    pilha->fundo = pilha->topo;        // 'fundo' aponta para a célula cabeça.
    pilha->topo->prox = NULL;          // Próximo do topo é NULL, indicando fim da pilha.
    pilha->tamanho = 0;                // Inicializa o tamanho da pilha com zero.
}




// Função que verifica se a pilha está vazia.
int vazia(TipoPilha *pilha) {
    // A pilha está vazia se o topo e o fundo apontam para a mesma célula.
    return (pilha->topo == pilha->fundo);
}




// Procedimento que empilha um item no topo da pilha.
void empilha(TipoItem x, TipoPilha *pilha) {
    Apontador aux;                               // Declara um ponteiro auxiliar.
    aux = (Apontador) malloc(sizeof(Celula));    // Aloca memória para a nova célula.
    aux->item = x;                               // Armazena o item 'x' na nova célula.
    aux->prox = pilha->topo;                     // Nova célula aponta para o topo atual.
    pilha->topo = aux;                           // Atualiza o topo para a nova célula.
    pilha->tamanho++;                            // Incrementa o tamanho da pilha.
}




// Função que desempilha o item do topo da pilha.
TipoItem desempilha(TipoPilha *pilha) {
    Apontador q;             // Ponteiro auxiliar para a célula a ser removida.
    TipoItem item;           // Variável para armazenar o item removido.

    // Verifica se a pilha está vazia.
    if (vazia(pilha)) {
        printf("Erro: pilha vazia\n");   // Mensagem de erro.
        item.chave = -1;                 // Valor indicador de erro.
        return item;                     // Retorna o item com chave inválida.
    } else {
        q = pilha->topo;                 // 'q' aponta para o topo atual.
        pilha->topo = q->prox;           // Atualiza o topo para o próximo elemento.
        item = q->item;                  // Copia o item da célula removida.
        free(q);                         // Libera a memória da célula removida.
        pilha->tamanho--;                // Decrementa o tamanho da pilha.
        return item;                     // Retorna o item removido.
    }
}




// Função que retorna o tamanho atual da pilha.
int tamanho(TipoPilha *pilha) {
    return pilha->tamanho;  // Retorna o campo 'tamanho' da estrutura da pilha.
}




// Programa de exemplo de uso da pilha.
int main() {
    TipoPilha pilha;
    TipoItem item;

    FPVazia(&pilha);  // Inicializa a pilha.

    // Empilha alguns itens.
    item.chave = 10;
    empilha(item, &pilha);

    item.chave = 20;
    empilha(item, &pilha);

    // Verifica o tamanho da pilha.
    printf("Tamanho da pilha: %d\n", tamanho(&pilha));

    // Desempilha um item.
    item = desempilha(&pilha);
    printf("Item desempilhado: %d\n", item.chave);

    // Verifica se a pilha está vazia.
    if (vazia(&pilha)) {
        printf("A pilha está vazia.\n");
    } else {
        printf("A pilha não está vazia.\n");
    }

    // Libera a célula cabeça restante.
    free(pilha.topo);

    return 0;
}






-----------------------------------------------------------------------------------------------------------
CODIGOS EM PSEUDOCODIGO
-----------------------------------------------------------------------------------------------------------

// Definição de tipos e estruturas

Tipo TipoChave é Inteiro  // Define 'TipoChave' como um inteiro.

Tipo TipoItem
    chave: TipoChave       // Campo 'chave' do tipo 'TipoChave'.
FimTipo

Tipo Apontador é Referência para Celula  // Define 'Apontador' como referência para 'Celula'.

Tipo Celula
    item: TipoItem         // Item armazenado na célula.
    prox: Apontador        // Referência para a próxima célula (nó) da pilha.
FimTipo

Tipo TipoPilha
    topo: Apontador        // Referência para o topo da pilha.
    fundo: Apontador       // Referência para o fundo da pilha (célula base).
    tamanho: Inteiro       // Tamanho atual da pilha.
FimTipo




// Procedimento que inicializa a pilha vazia.
Procedimento FPVazia(var pilha: TipoPilha)
    pilha.topo ← novo Celula       // Aloca memória para a célula cabeça.
    pilha.fundo ← pilha.topo       // 'fundo' aponta para a célula cabeça.
    pilha.topo.prox ← nulo         // Próximo do topo é nulo, indicando fim da pilha.
    pilha.tamanho ← 0              // Inicializa o tamanho da pilha com zero.
FimProcedimento




// Função que verifica se a pilha está vazia.
Função vazia(pilha: TipoPilha): Booleano
    retornar (pilha.topo = pilha.fundo)  // A pilha está vazia se topo e fundo são iguais.
FimFunção




// Procedimento que empilha um item no topo da pilha.
Procedimento empilha(x: TipoItem, var pilha: TipoPilha)
    var aux: Apontador                    // Declara um ponteiro auxiliar.
    aux ← novo Celula                     // Aloca memória para a nova célula.
    aux.item ← x                          // Armazena o item 'x' na nova célula.
    aux.prox ← pilha.topo                 // Nova célula aponta para o topo atual.
    pilha.topo ← aux                      // Atualiza o topo para a nova célula.
    pilha.tamanho ← pilha.tamanho + 1     // Incrementa o tamanho da pilha.
FimProcedimento




// Função que desempilha o item do topo da pilha.
Função desempilha(var pilha: TipoPilha): TipoItem
    var q: Apontador             // Ponteiro auxiliar para a célula a ser removida.
    var item: TipoItem           // Variável para armazenar o item removido.

    se vazia(pilha) então
        escrever "Erro: pilha vazia"   // Mensagem de erro.
        item.chave ← -1                // Valor indicador de erro.
        retornar item                  // Retorna o item com chave inválida.
    senão
        q ← pilha.topo                 // 'q' aponta para o topo atual.
        pilha.topo ← q.prox            // Atualiza o topo para o próximo elemento.
        item ← q.item                  // Copia o item da célula removida.
        liberar q                      // Libera a memória da célula removida.
        pilha.tamanho ← pilha.tamanho - 1  // Decrementa o tamanho da pilha.
        retornar item                  // Retorna o item removido.
    fim se
FimFunção




// Função que retorna o tamanho atual da pilha.
Função tamanho(pilha: TipoPilha): Inteiro
    retornar pilha.tamanho  // Retorna o campo 'tamanho' da estrutura da pilha.
FimFunção




// Programa principal para demonstração.
Algoritmo Principal
    var pilha: TipoPilha
    var item: TipoItem

    FPVazia(pilha)  // Inicializa a pilha.

    // Empilha alguns itens.
    item.chave ← 10
    empilha(item, pilha)

    item.chave ← 20
    empilha(item, pilha)

    // Verifica o tamanho da pilha.
    escrever "Tamanho da pilha: ", tamanho(pilha)

    // Desempilha um item.
    item ← desempilha(pilha)
    escrever "Item desempilhado: ", item.chave

    // Verifica se a pilha está vazia.
    se vazia(pilha) então
        escrever "A pilha está vazia."
    senão
        escrever "A pilha não está vazia."
    fim se

    // Libera a célula cabeça restante.
    liberar pilha.topo

FimAlgoritmo
