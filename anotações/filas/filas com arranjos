### Filas (Queues)

As filas são estruturas de dados lineares em que a ordem de inserção dos elementos determina a ordem de remoção. 
Elas seguem o princípio **FIFO** (First-In, First-Out), ou seja, o primeiro elemento inserido é o primeiro a ser removido.

#### Analogia:
Pense em uma fila de espera em um caixa de supermercado. A pessoa que está no início da fila é atendida primeiro, 
enquanto as novas pessoas que chegam entram no final da fila.

---

### Características das Filas

- **Operações de Inserção (Enqueue):** São feitas na extremidade chamada "traseira" da fila.
- **Operações de Remoção (Dequeue):** São feitas na extremidade oposta, chamada "frente" da fila.

---

### Implementação de Filas Usando Arranjos

- Os elementos são armazenados em posições contíguas na memória.
  
- **Enfileirar (Enqueue):** 
  - Adiciona um novo elemento ao final da fila.

- **Desenfileirar (Dequeue):**
  - Remove o elemento do início da fila.

#### Problema Comum:
À medida que elementos são inseridos no final e removidos do início, a fila tende a "mover-se" para frente na memória.
Isso pode levar a um problema onde a fila atinge o limite do espaço alocado, mesmo que existam espaços livres no início do array.

#### Solução:
Para resolver esse problema, podemos tratar o array como se fosse circular. Isso significa que, 
quando o final da fila atinge o final do array, ele "envolve" e começa novamente a partir do início do array, se houver espaço disponível.

---

### Filas Circulares

Em uma fila circular, a primeira posição do array segue a última, formando um "círculo".

- **Enfileirar (Enqueue):**
  - Adiciona um elemento na posição apontada por "Trás".
  - Movimenta o apontador "Trás" uma posição para frente (sentido horário).
  - Se "Trás" atingir o final do array, ele se move para o início, se houver espaço.

- **Desenfileirar (Dequeue):**
  - Remove o elemento da posição apontada por "Frente".
  - Movimenta o apontador "Frente" uma posição para frente.
  - Se "Frente" atingir o final do array, ele se move para o início.

---

### Vantagens da Implementação Circular

- **Eficiência no Uso de Memória:**
  - Evita o desperdício de espaço na memória, já que o espaço no início do array pode ser reutilizado quando o final da fila atinge o limite.

- **Operações Constantes:**
  - Tanto as operações de enfileirar quanto as de desenfileirar são realizadas em tempo constante O(1),
pois apenas envolvem a movimentação de apontadores e, no máximo, a atualização de índices.

---

------------------------------------------------------------------------------------
CODIGO EM C++
------------------------------------------------------------------------------------

#define MAXTAM 1000
typedef int TipoApontador;
typedef int TipoChave;

// Definição do item da fila
typedef struct {
    TipoChave Chave;
} TipoItem;

// Definição da estrutura da fila
typedef struct {
    TipoItem item[MAXTAM];
    TipoApontador frente, tras;
} TipoFila;

// Função para inicializar a fila vazia
void FFVazia(TipoFila *Fila) {
    Fila->Frente = 0;  // Inicializa o ponteiro frente na posição 0
    Fila->Tras = 0;    // Inicializa o ponteiro tras na mesma posição, indicando fila vazia
}

// Função que verifica se a fila está vazia
int Vazia(TipoFila *Fila) {
    return (Fila->Frente == Fila->Tras);  // Se frente e tras são iguais, a fila está vazia
}

// Função para inserir um item na fila (Enfileirar)
int Enfileira(TipoItem x, TipoFila *Fila) {
    // Verifica se a fila está cheia
    if ((Fila->Tras + 1) % MAXTAM == Fila->Frente) {
        printf("Erro: fila está cheia"); 
        return 0;  // Retorna 0 para indicar falha na inserção
    } else {
        // Insere o item na posição apontada por tras
        Fila->item[Fila->Tras] = x;
        // Move o ponteiro tras para a próxima posição circularmente
        Fila->Tras = (Fila->Tras + 1) % MAXTAM;
    }
    return 1;  // Retorna 1 para indicar sucesso na inserção
}

// Função para remover um item da fila (Desenfileirar)
TipoItem Desenfileira(TipoFila *Fila) {
    if (Vazia(Fila)) {
        printf("Erro: fila está vazia\n"); 
        // Retorna um item com chave -1 para indicar erro
        TipoItem itemVazio;
        itemVazio.Chave = -1;
        return itemVazio;
    } else {
        // Armazena o índice do item a ser removido
        int idx = Fila->Frente;
        // Move o ponteiro frente para a próxima posição circularmente
        Fila->Frente = (Fila->Frente + 1) % MAXTAM;
        // Retorna o item removido
        return Fila->item[idx];
    }
}



